import { create } from 'zustand';
import { persist } from 'zustand/middleware';
import { apiService, API_ENDPOINTS } from '../services/api/client';

export interface Vulnerability {
  id: string;
  title: string;
  description: string;
  severity: 'critical' | 'high' | 'medium' | 'low' | 'info';
  status: 'open' | 'in_progress' | 'resolved' | 'false_positive';
  cvss: number;
  cve?: string;
  target: string;
  targetName: string;
  discoveredAt: string;
  lastUpdated: string;
  assignedTo?: string;
  tags: string[];
  references?: string[];
  remediation?: string;
  affected: string;
  impact: string;
  evidence?: string;
  createdAt: string;
  updatedAt: string;
}

export interface VulnerabilityFilters {
  search?: string;
  severity?: string;
  status?: string;
  target?: string;
  assignedTo?: string;
  tags?: string[];
  dateFrom?: string;
  dateTo?: string;
}

export interface VulnerabilityState {
  vulnerabilities: Vulnerability[];
  selectedVulnerability: Vulnerability | null;
  loading: boolean;
  error: string | null;
  filters: VulnerabilityFilters;
  pagination: {
    page: number;
    limit: number;
    total: number;
    pages: number;
  };
  stats: {
    total: number;
    critical: number;
    high: number;
    medium: number;
    low: number;
    info: number;
    open: number;
    inProgress: number;
    resolved: number;
    falsePositive: number;
  };
}

export interface VulnerabilityActions {
  // State management
  setVulnerabilities: (vulnerabilities: Vulnerability[]) => void;
  setSelectedVulnerability: (vulnerability: Vulnerability | null) => void;
  setLoading: (loading: boolean) => void;
  setError: (error: string | null) => void;
  setFilters: (filters: VulnerabilityFilters) => void;
  setPagination: (pagination: VulnerabilityState['pagination']) => void;
  setStats: (stats: VulnerabilityState['stats']) => void;
  
  // CRUD operations
  fetchVulnerabilities: (params?: Record<string, any>) => Promise<void>;
  fetchVulnerability: (id: string) => Promise<void>;
  createVulnerability: (vulnerability: Omit<Vulnerability, 'id' | 'createdAt' | 'updatedAt'>) => Promise<void>;
  updateVulnerability: (id: string, vulnerability: Partial<Vulnerability>) => Promise<void>;
  deleteVulnerability: (id: string) => Promise<void>;
  
  // Bulk operations
  bulkUpdateStatus: (ids: string[], status: string) => Promise<void>;
  bulkAssign: (ids: string[], assignedTo: string) => Promise<void>;
  bulkDelete: (ids: string[]) => Promise<void>;
  
  // Vulnerability operations
  changeStatus: (id: string, status: string) => Promise<void>;
  assignVulnerability: (id: string, assignedTo: string) => Promise<void>;
  addComment: (id: string, comment: string) => Promise<void>;
  exportVulnerabilities: (format: string) => Promise<void>;
  
  // Utility actions
  clearError: () => void;
  resetFilters: () => void;
  addVulnerability: (vulnerability: Vulnerability) => void;
  removeVulnerability: (id: string) => void;
  updateVulnerabilityInList: (id: string, updates: Partial<Vulnerability>) => void;
  calculateStats: () => void;
}

export type VulnerabilityStore = VulnerabilityState & VulnerabilityActions;

const initialState: VulnerabilityState = {
  vulnerabilities: [],
  selectedVulnerability: null,
  loading: false,
  error: null,
  filters: {},
  pagination: {
    page: 1,
    limit: 10,
    total: 0,
    pages: 0,
  },
  stats: {
    total: 0,
    critical: 0,
    high: 0,
    medium: 0,
    low: 0,
    info: 0,
    open: 0,
    inProgress: 0,
    resolved: 0,
    falsePositive: 0,
  },
};

export const useVulnerabilityStore = create<VulnerabilityStore>()(
  persist(
    (set, get) => ({
      ...initialState,

      // State management
      setVulnerabilities: (vulnerabilities) => set({ vulnerabilities }),
      setSelectedVulnerability: (vulnerability) => set({ selectedVulnerability: vulnerability }),
      setLoading: (loading) => set({ loading }),
      setError: (error) => set({ error }),
      setFilters: (filters) => set({ filters }),
      setPagination: (pagination) => set({ pagination }),
      setStats: (stats) => set({ stats }),

      // CRUD operations
      fetchVulnerabilities: async (params = {}) => {
        const { filters, pagination } = get();
        
        set({ loading: true, error: null });
        
        try {
          const queryParams = {
            page: pagination.page,
            limit: pagination.limit,
            ...filters,
            ...params,
          };

          const response = await apiService.get<Vulnerability[]>(API_ENDPOINTS.VULNERABILITIES.LIST, queryParams);
          
          if (response.success) {
            set({
              vulnerabilities: response.data,
              pagination: response.pagination || pagination,
              loading: false,
            });
            
            // Calculate stats after fetching
            get().calculateStats();
          } else {
            set({ error: response.error || 'Failed to fetch vulnerabilities', loading: false });
          }
        } catch (error) {
          set({ error: 'Failed to fetch vulnerabilities', loading: false });
        }
      },

      fetchVulnerability: async (id: string) => {
        set({ loading: true, error: null });
        
        try {
          const response = await apiService.get<Vulnerability>(API_ENDPOINTS.VULNERABILITIES.GET(id));
          
          if (response.success) {
            set({ selectedVulnerability: response.data, loading: false });
          } else {
            set({ error: response.error || 'Failed to fetch vulnerability', loading: false });
          }
        } catch (error) {
          set({ error: 'Failed to fetch vulnerability', loading: false });
        }
      },

      createVulnerability: async (vulnerabilityData) => {
        set({ loading: true, error: null });
        
        try {
          const response = await apiService.post<Vulnerability>(API_ENDPOINTS.VULNERABILITIES.CREATE, vulnerabilityData);
          
          if (response.success) {
            const { vulnerabilities } = get();
            set({
              vulnerabilities: [...vulnerabilities, response.data],
              loading: false,
            });
            get().calculateStats();
          } else {
            set({ error: response.error || 'Failed to create vulnerability', loading: false });
          }
        } catch (error) {
          set({ error: 'Failed to create vulnerability', loading: false });
        }
      },

      updateVulnerability: async (id: string, vulnerabilityData) => {
        set({ loading: true, error: null });
        
        try {
          const response = await apiService.put<Vulnerability>(API_ENDPOINTS.VULNERABILITIES.UPDATE(id), vulnerabilityData);
          
          if (response.success) {
            const { vulnerabilities, selectedVulnerability } = get();
            const updatedVulnerabilities = vulnerabilities.map(vuln =>
              vuln.id === id ? { ...vuln, ...response.data } : vuln
            );
            
            set({
              vulnerabilities: updatedVulnerabilities,
              selectedVulnerability: selectedVulnerability?.id === id ? response.data : selectedVulnerability,
              loading: false,
            });
            get().calculateStats();
          } else {
            set({ error: response.error || 'Failed to update vulnerability', loading: false });
          }
        } catch (error) {
          set({ error: 'Failed to update vulnerability', loading: false });
        }
      },

      deleteVulnerability: async (id: string) => {
        set({ loading: true, error: null });
        
        try {
          const response = await apiService.delete(API_ENDPOINTS.VULNERABILITIES.DELETE(id));
          
          if (response.success) {
            const { vulnerabilities, selectedVulnerability } = get();
            const filteredVulnerabilities = vulnerabilities.filter(vuln => vuln.id !== id);
            
            set({
              vulnerabilities: filteredVulnerabilities,
              selectedVulnerability: selectedVulnerability?.id === id ? null : selectedVulnerability,
              loading: false,
            });
            get().calculateStats();
          } else {
            set({ error: response.error || 'Failed to delete vulnerability', loading: false });
          }
        } catch (error) {
          set({ error: 'Failed to delete vulnerability', loading: false });
        }
      },

      // Bulk operations
      bulkUpdateStatus: async (ids: string[], status: string) => {
        set({ loading: true, error: null });
        
        try {
          const response = await apiService.post(API_ENDPOINTS.VULNERABILITIES.BULK_UPDATE, {
            ids,
            status,
          });
          
          if (response.success) {
            const { vulnerabilities } = get();
            const updatedVulnerabilities = vulnerabilities.map(vuln =>
              ids.includes(vuln.id) ? { ...vuln, status: status as Vulnerability['status'] } : vuln
            );
            
            set({ vulnerabilities: updatedVulnerabilities, loading: false });
            get().calculateStats();
          } else {
            set({ error: response.error || 'Failed to update vulnerabilities', loading: false });
          }
        } catch (error) {
          set({ error: 'Failed to update vulnerabilities', loading: false });
        }
      },

      bulkAssign: async (ids: string[], assignedTo: string) => {
        set({ loading: true, error: null });
        
        try {
          const response = await apiService.post(API_ENDPOINTS.VULNERABILITIES.BULK_UPDATE, {
            ids,
            assignedTo,
          });
          
          if (response.success) {
            const { vulnerabilities } = get();
            const updatedVulnerabilities = vulnerabilities.map(vuln =>
              ids.includes(vuln.id) ? { ...vuln, assignedTo } : vuln
            );
            
            set({ vulnerabilities: updatedVulnerabilities, loading: false });
          } else {
            set({ error: response.error || 'Failed to assign vulnerabilities', loading: false });
          }
        } catch (error) {
          set({ error: 'Failed to assign vulnerabilities', loading: false });
        }
      },

      bulkDelete: async (ids: string[]) => {
        set({ loading: true, error: null });
        
        try {
          const response = await apiService.post(API_ENDPOINTS.VULNERABILITIES.BULK_UPDATE, {
            ids,
            action: 'delete',
          });
          
          if (response.success) {
            const { vulnerabilities, selectedVulnerability } = get();
            const filteredVulnerabilities = vulnerabilities.filter(vuln => !ids.includes(vuln.id));
            
            set({
              vulnerabilities: filteredVulnerabilities,
              selectedVulnerability: selectedVulnerability && ids.includes(selectedVulnerability.id) ? null : selectedVulnerability,
              loading: false,
            });
            get().calculateStats();
          } else {
            set({ error: response.error || 'Failed to delete vulnerabilities', loading: false });
          }
        } catch (error) {
          set({ error: 'Failed to delete vulnerabilities', loading: false });
        }
      },

      // Vulnerability operations
      changeStatus: async (id: string, status: string) => {
        set({ loading: true, error: null });
        
        try {
          const response = await apiService.patch(API_ENDPOINTS.VULNERABILITIES.UPDATE(id), { status });
          
          if (response.success) {
            const { vulnerabilities, selectedVulnerability } = get();
            const updatedVulnerabilities = vulnerabilities.map(vuln =>
              vuln.id === id ? { ...vuln, status: status as Vulnerability['status'] } : vuln
            );
            
            set({
              vulnerabilities: updatedVulnerabilities,
              selectedVulnerability: selectedVulnerability?.id === id ? { ...selectedVulnerability, status: status as Vulnerability['status'] } : selectedVulnerability,
              loading: false,
            });
            get().calculateStats();
          } else {
            set({ error: response.error || 'Failed to change status', loading: false });
          }
        } catch (error) {
          set({ error: 'Failed to change status', loading: false });
        }
      },

      assignVulnerability: async (id: string, assignedTo: string) => {
        set({ loading: true, error: null });
        
        try {
          const response = await apiService.patch(API_ENDPOINTS.VULNERABILITIES.UPDATE(id), { assignedTo });
          
          if (response.success) {
            const { vulnerabilities, selectedVulnerability } = get();
            const updatedVulnerabilities = vulnerabilities.map(vuln =>
              vuln.id === id ? { ...vuln, assignedTo } : vuln
            );
            
            set({
              vulnerabilities: updatedVulnerabilities,
              selectedVulnerability: selectedVulnerability?.id === id ? { ...selectedVulnerability, assignedTo } : selectedVulnerability,
              loading: false,
            });
          } else {
            set({ error: response.error || 'Failed to assign vulnerability', loading: false });
          }
        } catch (error) {
          set({ error: 'Failed to assign vulnerability', loading: false });
        }
      },

      addComment: async (id: string, comment: string) => {
        set({ loading: true, error: null });
        
        try {
          const response = await apiService.post(`${API_ENDPOINTS.VULNERABILITIES.GET(id)}/comments`, { comment });
          
          if (response.success) {
            // Update vulnerability with new comment
            const { vulnerabilities, selectedVulnerability } = get();
            const updatedVulnerabilities = vulnerabilities.map(vuln =>
              vuln.id === id ? { ...vuln, lastUpdated: new Date().toISOString() } : vuln
            );
            
            set({
              vulnerabilities: updatedVulnerabilities,
              selectedVulnerability: selectedVulnerability?.id === id ? { ...selectedVulnerability, lastUpdated: new Date().toISOString() } : selectedVulnerability,
              loading: false,
            });
          } else {
            set({ error: response.error || 'Failed to add comment', loading: false });
          }
        } catch (error) {
          set({ error: 'Failed to add comment', loading: false });
        }
      },

      exportVulnerabilities: async (format: string) => {
        set({ loading: true, error: null });
        
        try {
          const { filters } = get();
          const queryParams = { ...filters, format };
          
          await apiService.download(API_ENDPOINTS.VULNERABILITIES.EXPORT, queryParams);
          set({ loading: false });
        } catch (error) {
          set({ error: 'Failed to export vulnerabilities', loading: false });
        }
      },

      // Utility actions
      clearError: () => set({ error: null }),
      
      resetFilters: () => set({ filters: {} }),
      
      addVulnerability: (vulnerability) => {
        const { vulnerabilities } = get();
        set({ vulnerabilities: [...vulnerabilities, vulnerability] });
        get().calculateStats();
      },
      
      removeVulnerability: (id: string) => {
        const { vulnerabilities, selectedVulnerability } = get();
        const filteredVulnerabilities = vulnerabilities.filter(vuln => vuln.id !== id);
        
        set({
          vulnerabilities: filteredVulnerabilities,
          selectedVulnerability: selectedVulnerability?.id === id ? null : selectedVulnerability,
        });
        get().calculateStats();
      },
      
      updateVulnerabilityInList: (id: string, updates) => {
        const { vulnerabilities, selectedVulnerability } = get();
        const updatedVulnerabilities = vulnerabilities.map(vuln =>
          vuln.id === id ? { ...vuln, ...updates } : vuln
        );
        
        set({
          vulnerabilities: updatedVulnerabilities,
          selectedVulnerability: selectedVulnerability?.id === id ? { ...selectedVulnerability, ...updates } : selectedVulnerability,
        });
        get().calculateStats();
      },

      calculateStats: () => {
        const { vulnerabilities } = get();
        
        const stats = {
          total: vulnerabilities.length,
          critical: vulnerabilities.filter(v => v.severity === 'critical').length,
          high: vulnerabilities.filter(v => v.severity === 'high').length,
          medium: vulnerabilities.filter(v => v.severity === 'medium').length,
          low: vulnerabilities.filter(v => v.severity === 'low').length,
          info: vulnerabilities.filter(v => v.severity === 'info').length,
          open: vulnerabilities.filter(v => v.status === 'open').length,
          inProgress: vulnerabilities.filter(v => v.status === 'in_progress').length,
          resolved: vulnerabilities.filter(v => v.status === 'resolved').length,
          falsePositive: vulnerabilities.filter(v => v.status === 'false_positive').length,
        };
        
        set({ stats });
      },
    }),
    {
      name: 'vulnerability-store',
      partialize: (state) => ({
        vulnerabilities: state.vulnerabilities,
        filters: state.filters,
        pagination: state.pagination,
        stats: state.stats,
      }),
    }
  )
);

// Selectors for better performance
export const vulnerabilitySelectors = {
  getVulnerabilityById: (id: string) => (state: VulnerabilityStore) =>
    state.vulnerabilities.find(vuln => vuln.id === id),
  
  getVulnerabilitiesBySeverity: (severity: string) => (state: VulnerabilityStore) =>
    state.vulnerabilities.filter(vuln => vuln.severity === severity),
  
  getVulnerabilitiesByStatus: (status: string) => (state: VulnerabilityStore) =>
    state.vulnerabilities.filter(vuln => vuln.status === status),
  
  getVulnerabilitiesByTarget: (targetId: string) => (state: VulnerabilityStore) =>
    state.vulnerabilities.filter(vuln => vuln.target === targetId),
  
  getVulnerabilitiesByAssignee: (assignedTo: string) => (state: VulnerabilityStore) =>
    state.vulnerabilities.filter(vuln => vuln.assignedTo === assignedTo),
  
  getCriticalVulnerabilities: (state: VulnerabilityStore) =>
    state.vulnerabilities.filter(vuln => vuln.severity === 'critical'),
  
  getOpenVulnerabilities: (state: VulnerabilityStore) =>
    state.vulnerabilities.filter(vuln => vuln.status === 'open'),
  
  getVulnerabilitiesByTag: (tag: string) => (state: VulnerabilityStore) =>
    state.vulnerabilities.filter(vuln => vuln.tags.includes(tag)),
  
  getFilteredVulnerabilities: (state: VulnerabilityStore) => {
    const { vulnerabilities, filters } = state;
    let filtered = vulnerabilities;

    if (filters.search) {
      const search = filters.search.toLowerCase();
      filtered = filtered.filter(vuln =>
        vuln.title.toLowerCase().includes(search) ||
        vuln.description.toLowerCase().includes(search) ||
        vuln.targetName.toLowerCase().includes(search) ||
        vuln.cve?.toLowerCase().includes(search)
      );
    }

    if (filters.severity) {
      filtered = filtered.filter(vuln => vuln.severity === filters.severity);
    }

    if (filters.status) {
      filtered = filtered.filter(vuln => vuln.status === filters.status);
    }

    if (filters.target) {
      filtered = filtered.filter(vuln => vuln.target === filters.target);
    }

    if (filters.assignedTo) {
      filtered = filtered.filter(vuln => vuln.assignedTo === filters.assignedTo);
    }

    if (filters.tags && filters.tags.length > 0) {
      filtered = filtered.filter(vuln =>
        filters.tags!.some(tag => vuln.tags.includes(tag))
      );
    }

    if (filters.dateFrom) {
      filtered = filtered.filter(vuln => vuln.discoveredAt >= filters.dateFrom!);
    }

    if (filters.dateTo) {
      filtered = filtered.filter(vuln => vuln.discoveredAt <= filters.dateTo!);
    }

    return filtered;
  },
};

export default useVulnerabilityStore; 